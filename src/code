Pour Créer un Document mon backnd est réalisé ainsi :

url : http://localhost:8080/api/documents/{folderId}/upload
// Method : POST
NB : {folderId} est un paramètre de chemin d'URL qui doit être remplacé par l'ID du dossier dans lequel vous souhaitez créer le document.


Voici à  quoi resseemble mon backend :

@RestController

@RequestMapping("/documents")

public class DocumentController {

    @Autowired

    private DocumentUploadHelper documentUploadHelper;

    @Autowired

    private DocumentRepository documentRepository;

    @Autowired

    @Qualifier("privateS3Client")

    private ObjectStorageClient s3Client;



    @Operation(

            summary = "Upload a new file",

            parameters = {

                    @Parameter(ref = "entityIdHeader", required = true)

            }

    )

    @PostMapping(value = "/{folderId}/upload", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)

    public DocumentVersionDTO uploadDocumentVersion(

            @PathVariable Long folderId,

            @RequestParam("file") MultipartFile file,

            @RequestParam("name") String name,

            @RequestParam("description") String description,



            @RequestParam("version") String version,

            @RequestParam(value = "parentDocumentId", required = false) Long parentDocumentId,

            @RequestParam(value = "status", required = false, defaultValue = "DRAFT") String documentStatus,

            @RequestParam(value = "tags", required = false) Set<String> tags,

            @RequestParam(value = "metadata", required = false) Map<String, String> metadata,

            @ModelAttribute @GraphQLRootContext RequestContext context

    ) {

        CreateDocumentVersionRequest request = new CreateDocumentVersionRequest();

        request.setName(name);

        request.setDescription(description);

        request.setVersion(version);

        request.setFolderId(folderId);

        request.setParentDocumentId(parentDocumentId);

        DocumentStatus status = DocumentStatus.valueOf(documentStatus);

        request.setStatus(status);

        // Ajouter les tags et métadonnées s'ils sont fournis

        request.setTags(tags != null ? tags : new HashSet<>());

        request.setMetadata(metadata);

        return documentUploadHelper.uploadDocumentVersion(file, request, context);

    }


    Consigne : jee veux que tu corrige ma vue CreateDocumentVersion pour envoyer exactement ls paramétres attendus par le backend et fais le minutieuseement :

    NB : Fais aussi le console des paramétres avant l'envoi pour que je puisse les vérifier
    Voici les parties àà adapter pour qu'elles soient conformes à ce que le backend attend :
    import React, { useState, useEffect } from 'react';
    import { useNavigate, useParams, useSearchParams } from 'react-router-dom';
    import {DocumentStatus} from "../types";
    import {useCreateDocument} from "../hooks/useCreateDocument.ts";
    import  {FormData} from  "../types";
    import {BreadcrumbVersion} from "../components/createdocumentversion/BreadcrumbVersion.tsx";
    import {FormHeader} from "../components/createdocumentversion/FormHeader.tsx";
    import {MainSection} from "../components/createdocumentversion/MainSection.tsx";
    import {SideSection} from "../components/createdocumentversion/SideSection.tsx";
    import {TagsSection} from "../components/createdocumentversion/TagsSection.tsx";
    import {FormActions} from "../components/createdocumentversion/FormActions.tsx";
    import {MetadataSection} from "../components/createdocumentversion/MetadataSection.tsx";
    export function CreateDocumentVersion() {
        const navigate = useNavigate();
        const { documentId } = useParams();
        const [searchParams] = useSearchParams();
        const folderIdParam = searchParams.get('folderId');
        const effectiveFolderId = folderIdParam ? parseInt(folderIdParam) : null;
        const effectiveParentDocId = documentId ? parseInt(documentId) : null;
        const [formData, setFormData] = useState<FormData>({
            name: '',
            description: '',
            version: '1.0',
            fileType: 'pdf',
            file: null,
            status: DocumentStatus.DRAFT,
            folderId: effectiveFolderId,
            parentDocumentId: effectiveParentDocId,
            tags: [],
            metadata: {},
        });
        const [currentTag, setCurrentTag] = useState('');
        const [formErrors, setFormErrors] = useState<Partial<Record<keyof FormData, string>>>({});
        const [isSubmitting, setIsSubmitting] = useState(false);
        useEffect(() => {
            const timer = setTimeout(() => {
                const formContainer = document.querySelector('.form-container');
                if (formContainer) {
                    formContainer.classList.add('form-appear');
                    formContainer.classList.remove('opacity-0', 'translate-y-4');
                }
            }, 100);

            return () => clearTimeout(timer);
        }, []);
        const createDocument = useCreateDocument(() => {
            document.getElementById('success-message')?.classList.remove('hidden');
            setTimeout(() => {
                if (effectiveFolderId) {
                    navigate(`/documents/${effectiveFolderId}`);
                } else {
                    navigate('/documents');
                }
            }, 1200);
        });
        const validateForm = (): boolean => {
            const errors: Partial<Record<keyof FormData, string>> = {};

            if (!formData.name.trim()) {
                errors.name = 'Le nom du document est requis';
            }

            if (!formData.version.trim()) {
                errors.version = 'Le numéro de version est requis';
            } else if (!/^\d+(\.\d+)*$/.test(formData.version)) {
                errors.version = 'Format de version invalide (ex: 1.0, 2.3.1)';
            }

            setFormErrors(errors);
            return Object.keys(errors).length === 0;
        };
        const handleSubmit = async (e: React.FormEvent) => {
            e.preventDefault();
            if (validateForm()) {
                setIsSubmitting(true);
                try {
                    const documentData = {
                        name: formData.name,
                        description: formData.description,
                        version: formData.version,
                        fileType: formData.fileType,
                        fileSize: formData.file ? formData.file.size : 0,
                        filePath: formData.file ? `/documents/${formData.file.name}` : '',
                        status: formData.status,
                        folderId: formData.folderId,
                        parentDocumentId: formData.parentDocumentId,
                        tags: formData.tags,
                        metadata: formData.metadata
                    };

                    await createDocument.mutateAsync(documentData);
                } catch (error) {
                    console.error('Error creating document:', error);
                    setIsSubmitting(false);
                }
            }
        };
        return (
            <div className="min-h-screen bg-slate-50">
                <div className="container mx-auto max-w-5xl px-4 py-6 sm:py-10">
                    <BreadcrumbVersion />
                    <div className="bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden">
                        <FormHeader effectiveFolderId={effectiveFolderId} />
                        <form onSubmit={handleSubmit} className="p-6 space-y-8">
                            <div className="grid grid-cols-1 md:grid-cols-3 gap-x-8 gap-y-6">
                                <MainSection
                                    formData={formData}
                                    setFormData={setFormData}
                                    formErrors={formErrors}
                                    setFormErrors={setFormErrors}
                                />
                                <SideSection
                                    formData={formData}
                                    setFormData={setFormData}
                                    formErrors={formErrors}
                                    setFormErrors={setFormErrors}
                                />
                            </div>

                            <div className="grid grid-cols-1 md:grid-cols-2 gap-8 pt-4">
                                <TagsSection
                                    formData={formData}
                                    setFormData={setFormData}
                                    currentTag={currentTag}
                                    setCurrentTag={setCurrentTag}
                                />
                                <MetadataSection
                                    formData={formData}
                                    setFormData={setFormData}
                                />
                            </div>

                            <FormActions
                                effectiveFolderId={effectiveFolderId}
                                isSubmitting={isSubmitting}
                            />
                        </form>
                    </div>
                </div>
            </div>
        );
    }




-----------------------

import { useNavigate } from 'react-router-dom';
import { Save } from 'lucide-react';
import clsx from 'clsx';

interface FormActionsProps {
    effectiveFolderId: number | null;
    isSubmitting: boolean;
}

export function FormActions({ effectiveFolderId, isSubmitting }: FormActionsProps) {
    const navigate = useNavigate();

    return (
        <div className="pt-6 border-t border-slate-200 mt-8 flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-4 space-y-4 space-y-reverse sm:space-y-0">
            <button
                type="button"
                onClick={() => navigate(effectiveFolderId ? `/documents/${effectiveFolderId}` : '/documents')}
                className="px-5 py-2.5 border border-slate-300 text-slate-700 font-medium rounded-lg hover:bg-slate-50 transition-colors shadow-sm"
            >
                Annuler
            </button>
            <button
                type="submit"
                disabled={isSubmitting}
                className={clsx(
                    "px-5 py-2.5 bg-primary-600 text-black font-medium rounded-lg transition-colors shadow-sm flex items-center justify-center gap-2",
                    isSubmitting ? "opacity-80 cursor-not-allowed" : "hover:bg-primary-700"
                )}
            >
                {isSubmitting ? (
                    <>
                        <svg className="animate-spin h-4 w-4 text-slate-700" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                        Enregistrement...
                    </>
                ) : (
                    <>
                        <Save className="w-4 h-4" />
                        Enregistrer
                    </>
                )}
            </button>
        </div>
    );
}


NB : Tu dois ajouuter aussi sur la vue CreateDocumentVersion la ssection pour uploader le fichier



UseCreate:
import { useMutation, useQueryClient } from '@tanstack/react-query';
import documentService, { CreateDocumentData } from '../services/document-service';
import { Document } from "../types";

export const useCreateDocument = (onSuccess?: () => void) => {
    const queryClient = useQueryClient();

    return useMutation<Document, Error, CreateDocumentData>({
        mutationFn: documentService.createDocument,

        onMutate: async (newDocument) => {
            // Annuler les requêtes en cours
            await queryClient.cancelQueries({ queryKey: ['documents'] });

            if (newDocument.folderId) {
                await queryClient.cancelQueries({ queryKey: ['documents', newDocument.folderId] });
            }

            // Si c'est une version d'un document existant, annuler aussi les requêtes relatives au document parent
            if (newDocument.parentDocumentId) {
                await queryClient.cancelQueries({ queryKey: ['document', newDocument.parentDocumentId] });
                await queryClient.cancelQueries({ queryKey: ['document-versions', newDocument.parentDocumentId] });

                // Récupérer le document parent pour obtenir son folderId
                const parentDocument = queryClient.getQueryData<Document>(
                    ['document', newDocument.parentDocumentId]
                );

                // Si le document parent existe et qu'aucun folderId n'est spécifié, utiliser celui du parent
                if (parentDocument && !newDocument.folderId) {
                    newDocument.folderId = parentDocument.folderId;
                }
            }

            // Sauvegarde de l'état précédent
            const queryKey = newDocument.folderId
                ? ['documents', newDocument.folderId]
                : ['documents'];

            const previousDocuments = queryClient.getQueryData<Document[]>(queryKey) || [];

            // Document optimiste pour UI immédiate
            const optimisticDocument: Document = {
                ...newDocument,
                id: Math.random(),
                status: 'ACTIVE',
                versionIds: [],
                filePath: newDocument.filePath || '',
                fileSize: newDocument.fileSize || 0,
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString(),
                metadata: {
                    département: newDocument.metadata?.département || '',
                    confidentialité: newDocument.metadata?.confidentialité || '',
                    auteur: newDocument.metadata?.auteur || '',
                    ...(newDocument.metadata || {})
                },
                fileType: newDocument.fileType || '',
                version: newDocument.version || '1.0', // Version par défaut si non spécifiée
                folderId: newDocument.folderId || 0,
                parentDocumentId: newDocument.parentDocumentId || null,
                tags: newDocument.tags || []
            };

            // Mise à jour de l'UI avec le document optimiste
            queryClient.setQueryData<Document[]>(queryKey, [...previousDocuments, optimisticDocument]);

            return { previousDocuments, queryKey };
        },

        onSuccess: (newDocument) => {
            // Invalider les requêtes pour forcer un rafraîchissement
            queryClient.invalidateQueries({ queryKey: ['documents'] });

            if (newDocument.folderId) {
                queryClient.invalidateQueries({ queryKey: ['documents', newDocument.folderId] });
            }

            // Si c'est une nouvelle version, mettre à jour le document parent et ses versions
            if (newDocument.parentDocumentId) {
                queryClient.invalidateQueries({ queryKey: ['document', newDocument.parentDocumentId] });
                queryClient.invalidateQueries({ queryKey: ['document-versions', newDocument.parentDocumentId] });

                // Mettre à jour également la liste des versions du document parent
                const parentDocument = queryClient.getQueryData<Document>(['document', newDocument.parentDocumentId]);
                if (parentDocument && parentDocument.versionIds) {
                    queryClient.setQueryData(['document', newDocument.parentDocumentId], {
                        ...parentDocument,
                        versionIds: [...parentDocument.versionIds, newDocument.id]
                    });
                }
            }

            // Appeler le callback de succès si fourni
            if (onSuccess) {
                onSuccess();
            }
        },

        onError: (_, _newDocument, context: any) => {
            // En cas d'erreur, restaurer l'état précédent
            if (!context) return;
            queryClient.setQueryData(context.queryKey, context.previousDocuments);
        }
    });
};



Voici mon sseervice :
import { Document } from '../types';
import apiClient from './api-client';
export interface CreateDocumentData {
    fileSize: number;
    filePath: string;
    name: string;
    description: string;
    version?: string;
    fileType?: string;
    folderId?: number | null;
    parentDocumentId?: number | null;
    tags?: string[];
    metadata?: Record<string, string>;
}

class DocumentService {

    async createDocument(document: CreateDocumentData): Promise<Document> {
        const res = await apiClient.post<Document>('/documents', document);
        return res.data;
    }

}

export default new DocumentService();
